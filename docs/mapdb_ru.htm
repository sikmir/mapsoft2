<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>mapsoft2 documentation</title>
  <meta name="keywords" content="mapsof2">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body bgcolor="#FFFFFF">



<div align=right>
Язык:
<b>RU</b>
<a href="mapdb.htm">EN</a>
</div>

<a href="index.ru.htm">На главную...</a>


<h2>
  Векторные карты в Mapsoft2 (2020-02-15)
</h2>





<p>В данный момент поддержка векторных карт в mapsoft находится
в состоянии разработки. Еще не все сделано, возможны любые изменения.

<!--#################################################################-->

<hr><h3>Формат MapDB для хранения карт и интерфейс в mapsoft2</h3>

MapDB - формат для хранения векторных карт в mapsoft2. Он представляет из
себя директорию с несколькими базами данных BerkleyDB:

<ul>
<li> mapinfo.db -- информация о карте
<li> geohash.db -- данные для гео-индексации
<li> objects.db -- информация об объектах
</ul>


<p>Кроме того, в этой же директории могут находиться разные дополнительные
файлы, например, конфигурационный файл для изготовления растровых
картинок.

<p>В данный момент никакого окружения BerkleyDB не создается, каждый файл
является независимой базой данных, одновременно работать с базой данный
может только одна программа. В будущем при необходимости можно будет
делать окружение с блокировками, логами, транзакциями... В базах данных
используются только дефолтные функции сравнения ключей, поэтому все
утилиты для работы с базами BerkleyDB (db_load/db_dump и т.п.) должны
работать.

<p>В базах данных mapinfo.db, objects.db используется целый
32-битный ключ и произвольные данные в качестве значения. В этих данных
может быть запакована достаточно сложная структура. При это используется
упаковка данных в стиле RIFF: 4-символьный тэг ("crds", "name" и т.п.),
4-байтовое число - длина данных в байтах, данные. Для текстовых данных
(название объекта, комментарии и т.п.) используется кодировка UTF8.

<div class="c_api">
<p>В mapsoft2 карта представляется классом MapDB (см. modules/mapdb/mapdb.h).

<p><tt>  MapDB::MapDB(std::string name, bool create = false)</tt> --
Конструктор. Если create==false, то открывает существующую карту,
находящуюся в директории name (если карты не существует, возникает ошибка).
Иначе - создать карту в директории name (директория при необходимости создается,
если какие-то базы данных существуют - возникает ошибка).

<p><tt>  static void delete_db(std::string name)</tt> -- Функция для
удаления всех баз данных, относящихся к карте.


</div>

<!--########################-->
<h4>База данных mapinfo.db</h4>

База данных с 4-байтовым целочисленным ключем для хранения различной
информации о карте. В данный момент поддерживаются следующие ключи:

<ul>

<li>0. Версия формата MapDB, целое число записанное в виде строки.
Сейчас, пока формат еще активно разрабатывается и меняется, это "0".

<p>При открытии карты проверяется ее версия. Если версия карты не
установлена (например, база данных создается заново) то устанавливается
актуальное значение (зашитое в программе). Если версия карты новее, чем
это значение, то возникает ошибка.

<li>1. Название карты (строка). Устанавливается пользователем,
может иметь любое значение.

<li>2. Граница карты. Многоугольник с несколькими сегментами (объект
dMultiLine) упакованный в стиле RIFF с тэгом "crds" для каждого
сегмента. Сегмент состоит из пар координат (lon1,lat1,
lon2,lat2,...), Координаты - градусы в системе WGS84, умноженные на 1e7 и
округленные к ближайшему 4-байтовому целому числу. Граница карты
может быть установлена пользователем и иметь любое значение (в частности,
быть пустой).
</ul>

<p>Есть ощущение, что поле границы карты может быть ненужным (и пока оно
нигде не используется). Границу можно хранить в конфигурационном файле
для изготовления растровых картинок и использовать разные границы для
разных картинок изготовленных из одной карты. То же самое - с именем
карты.

<div class="c_api">
<p>Функции для работы с информацией о карте:

<p><tt>uint32_t MapDB::get_map_version() const;</tt> -- получить версию карты
версии.

<p><tt>  std::string MapDB::get_map_name()</tt> -- получить имя карты

<p><tt>  void MapDB::set_map_name(const std::string & name)</tt> -- изменить имя карты.

<p><tt>  dMultiLine MapDB::get_map_brd()</tt> -- получить границу карты

<p><tt>  void MapDB::set_map_brd(const dMultiLine & b)</tt> -- установить границу карты
<div>

<!--########################-->
<h4>База данных geohash.db</h2>

<p>База данных для геоиндексации. Ключ базы состоит из типа объекта
(целое беззнаковое число, 32 бита) и строки <a href="https://en.wikipedia.org/wiki/Geohash">Geohash</a>. Значение -
идентификатор объекта. Ключи могут повторяться. Обычно для объекта
создается до четырех записей, при этом исключаются слишком короткие
геохэши для небольших объектов, попавших на границы деления. Данные
должны быть синхронизованы с координатами в базе данных objects.db.


<!--########################-->
<h4>База данных objects.db</h2>

<p>Информация об объектах. Ключ - идентификатор объекта (беззнаковое
32-битовое целое число), значение - структура со следующими полями:

<ul>

<li>Тип объекта, 32-битное целое число. Старший байт - классификации
объекта (0-точка, 1-линия, 2-многоугольник, 3-текст), второй байт не
используется, два младших байта - собственно тип объекта (то же, что тип
в MP).

<p>Все остальные поля - необязательны. Они запакованы в стиле RIFF в
произвольном порядке.

<li>Наклон объекта представлен в виде 4-байтового вещественного числа, в
градусах. Запакован с тэгом "angl". Отсчитывается от географического
севера по часовой стрелке. Наклон влияет не на координаты объекта, а на
текст и разные картинки, которые с объектом связаны. Отсутствие
информации о наклоне или значение NaN означает, что картинки будут
ориентирован на верх карты.

<li>Масштаб объекта представлен в виде 4-байтового вещественного числа.
Запакован с тэгом "scle". Должен влиять на размер линий, картинок, текста
объекта при рисовании (пока это не реализовано).

<li>Выравнивание. Один байт, запакованный с тэгом "algn". Возможные значения:
(0..8: SW,W,NW,N,NE,E,SE,S,C), отсутствующее значение эквивалентно SW(0). Имеет смысл
для текстовых объектов.

<li>Название объекта, строка, запакованая
с тэгом "name". То, что должно отображаться на карте.

<li>Комментарий к объекту, строка, запакованая с тэгом "comm". На карте
не показывается.

<li>Тэги объекта, произвольное число строк, запакованных с тэгами "tags".
Могут быть использованы для маркировки некоторой части объектов. Например,
при импорте перевалов из каталога перевалов все они маркируются неким тэгом.
При обновлении старые объекты с этим тэгом удаляются и добавляются новые
(Тут, кстати, будет важна перепривязка подписей!)

<li>Зависимые объекты, беззнаковые 4-байтовые числа, каждое из которых
запаковано с тэгом "chld" (ID объектов в базе objects.db). Таким образом
объект может быть связан со своими подписями.

<li>Координаты. Многосегментная линия, закодированная в строку также, как
поле границы карты в базе данных mapinfo.db с тэгами "crds" для каждого
сегмента. Сегмент состоит из пар координат (lon1,lat1, lon2,lat2,...),
Координаты - градусы в системе WGS84, умноженные на 1e7 и округленные к
ближайшему 4-байтовому целому числу. При обновлении координат объекта
также должна обновляться база геоиндексации.

<p>TODO: сделать ли идентификатор 64-битным? Или вообще произвольной длины
(16,32,64 бита) - для экономии размера базы?

</ul>

<p> С точки зрения базы данных никакой разницы между точками, линиями,
площадными и текстовыми объектами нет. Различается только тип объекта. В данный момент
не слишком хорошо определено, как должен обрабатываться точечный или
текстовый объект, содержащий несколько координат. Должна
ли использоваться только первая точка или все точки? Должны ли линии в
текстовом объекте использоваться для рисования текста вдоль кривого контура?

<p>Объекты не могут быть пустыми (не содержать координат). Такой запрет
связан с невозможностью разместить такой объект в базе geohash.db.

<div class="c_api">
<p>В mapsoft2 объект представлен классом MapDBObj (см. modules/mapdb/mapdb.h).
Для него определены операции сравнения, конструктор с некими дефолтными
значениями, функции для запаковки/распаковки объекта при хранении в базе
данных.

<p>Карта имеет следующие функции для работы с объектами (эти функции
используют базу данных objects.db для чтения/записи информации об
объектах и базу данных geohash.db для работы с геоиндексацией, обеспечивая их
синхронизацию):

<p><tt>  uint32_t MapDB::add(const MapDBObj & o)</tt> -- добавить новый объект
на карту, вернуть его идентификатор. Идентификатор получается добавлением
единицы к самому большому идентификатору данной карты (или 0, если карта
пуста). При переполнении возникает ошибка. При попытке положить пустой объект
(без координат) возникает ошибка.

<p><tt>  void MapDB::put(uint32_t id, const MapDBObj & o)</tt> --
перезаписать объект с заданным идентификатором. Если объект не
существует, он создается. При попытке записать пустой объект
(без координат) возникает ошибка.

<p><tt>  MapDBObj MapDB::get(const uint32_t id)</tt> --
прочитать объект с заданным идентификатором.

<p><tt>  void MapDB::del(uint32_t id)</tt> -- удалить объект с заданным
идентификатором. Если объект не существует, возникает ошибка.

<p><tt>  std::set<uint32_t> find(MapDBObjClass cl, uint16_t tnum,   const
dRect & range) </tt> -- найти идентификаторы объектов заданного типа,
которые попадают в заданный диапазон координат. Параметр cl может
принимать следующие значения: 0 or MAPDB_POINT, 1 or MAPDB_LINE, 2 or
MAPDB_POLYGON, tnum - 16-битный номер типа.

<p><tt>  std::set<uint32_t> find(int type, const dRect & range) </tt> --
то же самое, но используется 32-битный тип. Функции find позволяет быстро
выбрать все объекты, которые могут попасть (но не обязательно попадают) в
заданный диапазон координат. При выполнении каких-то медленных операция с
объектами может иметь смысл дополнительно проверить попадание объекта в
нужный диапазон.

<p><tt>  std::set<uint32_t> get_types() </tt> -- Получить множество всех
типов объектов в базе данных. Возвращаются 32-битные типы.
</div>


<!--#################################################################-->
<!--#################################################################-->
<hr><h3>Программа ms2mapdb для работы с векторными картами</h3>


<p>Для произведения разных операций с векторными картами используется
программа ms2mapdb:

<p><tt><pre>
$ ms2mapdb (-h|--help|--pod)
$ ms2mapdb <action> (-h|--help)
$ ms2mapdb <action> [<action arguments and options>]
</pre></tt>

<p>Операции (actions):

<ul>
<li><tt>create -- создать новую карту
<li><tt>delete -- удалить все базы данных, относящиеся к карте
<li><tt>add_obj -- добавить новый объект
<li><tt>import_mp</tt> -- загрузить карту в формате MP
<li><tt>export_mp</tt> -- сохранить карту в формате MP
<li><tt>import_vmap</tt> -- загрузить карту в формате VMAP
<li><tt>export_vmap</tt> -- сохранить карту в формате VMAP
<li><tt>render</tt> -- получить изображение карты
</ul>

TODO: удаление объектов по id, тэгу или типу, удаление всех объектов;
импорт/экспорт в геоданные

<!--#################################################################-->
<!--#################################################################-->
<hr><h3>Формат MP</h3>

<!--########################-->
<h4>Поддержка формата MP в mapsoft2</h4>

<p>Описание формата:
<a href="http://magex.sourceforge.net/doc/cGPSmapper-UsrMan-v02.4.pdf">http://magex.sourceforge.net/doc/cGPSmapper-UsrMan-v02.4.pdf</a>

<p>В mapsoft2 карта представляется классом MP, а объект - классом MPObj
(см. modules/mp/mp.h) Поддерживается чтение и запись карты в MP-файл.
Читаются и записываются:

<p>Заголовок файла, секция [IMG ID], включая комментарии, находящиеся
перед этой секцией. Внутри секции может находиться большое число разных
параметров, записанных в виде &lt;ключ&gt;=&lt;значение&gt; Часть
параметров читаются в соответствующие поля структуры MP и проверяются.
Остальные хранятся в виде текстовых строк в объект типа Opt. Таким
образом, при чтении и записи файла пaрaметры, даже нестандартные, не
должны теряться (но если файл импортируется в MapDB, то почти все -
теряется). Если читаются несколько файлов MP, то используется заголовок
от последнего файла, а все объекты объединяются.

<p>Точечные, линейные и площадные объекты, секции [POI], [POLYLINE],
[POLYGON], включая комментарии, находящиеся перед этими секциями. При
чтении понимаются старые названия секций [RNG*]. Остальные секции не
читаются. В каждом объекте читаются параметры Type, Label, EndLevel,
Data* или Origin*. Данные могут находиться в разных слоях,
объявленных в заголовке. TODO: читать/записывать все поля, в том
числе - нестандартные, использующиеся в mapsoft1.

<p>Параметр заголовка CodePage (если он присутствует) используется для
преобразования текстовых строк: имени карты (Name), комментариев и всех
неизвестных параметров. Значение должно соответствовать windows codepage,
по умолчанию: 1251 (возможно, следует заменить на что-то более нейтральное).

<p>При чтении объектов поддерживается нестандартный параметр Direction,
который был использован в mapsoft1. Если Direction==2, то координаты
линий объекта сохраняются в обратном порядке. При записи параметр Direction
не используется.

<!--########################-->
<hr><h4>Импорт и экспорт карт в формате MP</h4>

<p>Для импорта карты из формата MP ("Польский" формат) в формат MapDB
используется метод <tt>MapDB::import_mp<tt> или программа
ms2mapdb.

<p><tt> void MapDB::import_mp(const string & mp_file, const Opt & opts)</tt>

<p><tt> $ ms2mapdb import_mp &lt;mapdb_folder&gt; &lt;mp_file&gt; &lt;options&gt;</tt>

<p>Параметр <tt>--config &lt;file&gt;</tt> задает конфигурационный файл.
При использовании конфигурационного файла объекты по умолчанию не
импортируются, все нужные правила надо явно указать в файле. Если же
конфигурационный файл не используется, то все объекты импортируются с
сохранением типов. В дополнение к конфигурационному файлу можно
использовать параметры командной строки (они имеют приоретет). В
конфигурационном файле допустимы комментарии (начинающиеся с символа #),
пустые строки, одинарные и двойные кавычки, символ \ для защиты
специальных символов. Могут использоваться следующие команды:

<ul>

<li><tt>(point|line|area) &lt;in_type&gt; [&lt;out_type&gt;]</tt> --
преобразовать точечные, линейные, площадные объекты с типом in_type в тип
out_type. Значение in_type=0 соответствует объектам любого типа. Значение
out_type=0 (или отсутствие этого аргумента) означает, что тип объекта не
меняется. Из нескольких строчек, относящихся к одному объекту приоритет
имеет первая. Например, строчка <tt>line 0x10 0x11</tt> означает, что
линии с типом 0x10 преобразуются в линии с типом 0x11. Следующая линия
<tt>line 0</tt> означает, что все остальные линии преобразуются без
изменения типа. Правила преобразования типов можно также задать с помощью
параметров командной строки: --cnv_points, --cnv_lines, --cnv_areas.
Аргумент этих команд - json-массив из пар чисел, например
[[10,10],[0,0]]. Шестнадцатеричные числа можно записывать в виде строк
[["0x16","0xA"]. Параметры командной строки имеют приоритет над
конфигурационным файлом.

<li><tt>level &lt;N&gt;</tt> -- брать данные, соответствующие определенному
уровню детализации. Соответствующий параметр командной строки: --data_level.

</ul>


<p>Для экспорта карты из MapDB в формат MP используется метод
export_mp или вызов программы ms2mapdb:

<p><tt> void MapDB::export_mp(const string & mp_file, const Opt & opts)</tt>

<p><tt> $ ms2mapdb export_mp &lt;mapdb_folder&gt; &lt;mp_file&gt; &lt;options&gt;</tt>

<p>Использование параметров командной строки и конфигурационного файл аналогично
импорту карт. Допустимые команды:

<ul>

<li><tt>(point|line|area) &lt;in_type&gt; [&lt;out_type&gt;]</tt> --
см. import_mp.

<li><tt>codepage &lt;value&gt;</tt> -- установить кодировку MP-файла
(windows codepage). Соответствующий параметр командной строки:
--codepage.

<li><tt>name &lt;value&gt;</tt> -- Установить имя MP-файла.
Соответствующий параметр командной строки: --name.

<li><tt>id &lt;value&gt;</tt> -- Установить ID MP-файла. Соответствующий
параметр командной строки: --id.

</ul>

<!--#################################################################-->
<!--#################################################################-->
<hr><h3>Формат VMAP</h3>

VMAP - текстовый формат хранения векторнных карт, использующийся в
mapsoft1.

<p>Для импорта карты из MapDB в формат VMAP используется метод
export_vmap или вызов программы ms2mapdb:

<p><tt> void MapDB::export_vmap(const string & vmap_file, const Opt & opts)</tt>

<p><tt> $ ms2mapdb export_vmap &lt;mapdb_folder&gt; &lt;vmap_file&gt; &lt;options&gt;</tt>

<p>Использование параметров командной строки и конфигурационного файл аналогично
импорту карт в формате MP. Допустимые команды:

<ul>

<li><tt>(point|line|area) &lt;in_type&gt; [&lt;out_type&gt;]</tt> --
см. import_mp.

</ul>

<p>Для экспорта карты из MapDB в формат VMAP используется метод
export_vmap или вызов программы ms2mapdb:

<p><tt> void MapDB::export_vmap(const string & vmap_file, const Opt & opts)</tt>

<p><tt> $ ms2mapdb export_vmap &lt;mapdb_folder&gt; &lt;vmap_file&gt; &lt;options&gt;</tt>

<p>Использование параметров командной строки и конфигурационного файл аналогично
экспорту карт в формате MP. Допустимые команды:

<ul>

<li><tt>(point|line|area) &lt;in_type&gt; [&lt;out_type&gt;]</tt> --
см. import_mp.

</ul>

<!--#################################################################-->
<!--#################################################################-->
<hr><h3>Рендер изображения карты</h3>

<p>Для получения изображение карты можно использовать команду командной строки:

<p><tt> $ ms2mapdb render &lt;mapdb_folder&gt; &lt;options&gt;</tt>

<p>Конфигурационный файл передается через параметр --config. По умолчанию
используется файл render.cfg в директории MapDB.

<p>Кроме того, изображение карты можно смотреть в программе ms2view, передав
директорию с картой через параметр командной строки --mapdb и название
конфигурационного файла через параметр --mapdb_config.

<h4>Формат конфигурационного файла и порядок рисования карты</h4>

<p>Рисование карты выполняется в виде последовательности "шагов" (drawing
steps). Каждый шаг описан в конфигурационном файле и содержит набор
свойств (feature). Также, конфигурационный файл может содержать команды,
не являющиеся шагами рисования. Пример конфигурационного файла: data/render.cfg

Формат описания шагов рисования:
<pre><tt>
    (point|line|area|text):&lt;tnum&gt; &lt;feature&gt; &lt;options&gt; ...
    + &lt;feature&gt; &lt;options&gt; ...
    + &lt;feature&gt; &lt;options&gt; ...
    ...
    map &lt;feature&gt; &lt;options&gt; ...
    + &lt;feature&gt; &lt;options&gt; ...
    + &lt;feature&gt; &lt;options&gt; ...
    ...
</tt></pre>

<p>Шаги point, line, area описывают рисование линейного, точечного, площадного
объекта с номером типа &lt;tnum&gt;. Шаг map описывает рисование на всей площади карты
(можно нарисовать одноцветную подложку, но можно делать и более хитрые
вещи).

<p>TODO: шаг для рисования границы.

<p>Свойства (features):
<ul>

<li><tt> stroke &lt;width&gt; &lt;color&gt; </tt> -- Нарисовать контур
объекта линией заданной толщины и цвета. Применимо к шагам point, line,
area, text. Цвет всегда задается в виде 32-битного числа с прозрачностью
(0xFF000000 - черный, 0xFFFF0000 - красный, 0x80FFFFFF - белый
полупрозрачный и т.п.). Для текстового объекта линией обводятся контуры букв.

<li><tt> fill &lt;color&gt; </tt> -- Заливка заданным цветом. Применимо
к шагам line, area, map, text. Для текстового объекта заливка применяется
к контурам букв. Результат немного отличается от использования стандартной
функции рендера текста (см. свойство write ниже).

<li><tt> font &lt;size&gt; &lt;font pattern&gt;</tt> -- Установить шрифт
для рисования текстовых объектов. "font pattern" задается в терминах библиотеки
fontconfig, какая-то информация есть тут:
<br><a href="https://www.freedesktop.org/software/fontconfig/fontconfig-devel/x19.html">https://www.freedesktop.org/software/fontconfig/fontconfig-devel/x19.html</a>
<br><a href="https://www.freedesktop.org/software/fontconfig/fontconfig-user.html">https://www.freedesktop.org/software/fontconfig/fontconfig-user.html</a>
<br><a href="https://wiki.archlinux.org/index.php/Font_configuration">https://wiki.archlinux.org/index.php/Font_configuration</a>

<li><tt> write &lt;color&gt; </tt> -- Нарисовать текстовый объект заданным цветом.


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render01.png align=right>
# Пример конфигурационного файла: свойства stroke, fill и write

# Во всех примерах ниже используется карта с одинаковыми объектами,
# меняются лишь правила рисования (см. docs/render_examples).

# шаг1: заполняем карту белым цветом (не обязательно, так как по умолчанию
# цвет подложки - белый)
map fill 0xFFFFFFFF

# шаг2: рисуем площадной объект типа 1 с
# зеленой границей толщины 1 и светло-зеленой заливкой
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA

# шаг3: рисуем линейный объект типа 1 синей линией с толщиной 2
line:1 stroke 0xFF0000FF 2

# шаг4: рисуем точечный объект типа 1 красный точкой диаметром 8
point:1 stroke 0xFFFF0000 8

# шаг5: текст (цвет синий, размер - 10px, шрифт - DejaVu Sans)
# кроме того, обводим контур белой линией толщиной 4
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render14.png align=right>
# Нарисовать текст можно, используя свойство fill вместо write,
# В этом случае вместо стандартной функции рендера текста
# создается контур, который заливается нужным цветом.
# Результат немного отличается.

# кроме того, здесь же я даю пример использования команды define
# (см. ниже)

define white 0xFFFFFFFF
define green 0xFF00FF00
define blue  0xFF0000FF
define light_green 0xFFAAFFAA
define myfont "DejaVu Sans:Bold:semicondensed:rgba=none"

map fill white
area:1 stroke green 1
+      fill light_green
line:1 stroke blue 2

# текст:
text:1 font 10 myfont
+      stroke white 4
text:1 font 10 myfont
+      fill blue

# (Для текста можно использовать и свойство patt, заливать
# контур картинкой, хотя непонятно, зачем бы это могло пригодится...)


</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render07.png align=right>
# Пример с полупрозрачными цветами

map fill 0xFFFFFFFF

area:1 stroke 0xFF00FF00 4
+      fill 0xFFAAFFAA

# линия имеет полупрозрачный цвет
line:1 stroke 0x800000FF 5

point:1 stroke 0xFFFF0000 8

# шаг5: текст с полупрозрачным контуром вокруг
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0x7FFFFFFF 4

# белая полупрозрачная заливка поверх всего
map fill 0x80FFFFFF

</div><br>

<li><tt> patt &lt;image file&gt; &lt;scale&gt; &lt;dx&gt; &lt;dy&gt;
</tt> --  Заливка площади заданной картинкой. Применимо к шагам line,
area, text, map. Картинка - в любом растровом формате, поддержтиваемом
mapsoft2: png, gif, tiff, jpeg. Путь к картинке должен быть указан
относительно места, где лежит конфигурационный файл. Параметр scale -
масштаб картинки, dx и dy - сдвиг картинки (в единицах размера картинки).
По умолчанию картинка выравнивается по центру. Если dx=dy=-0.5, то
выравнивание будет сделано по левому-нижнему углу. ля текстового объекта
заливка применяется к контурам букв.

TODO: векторные форматы типа svg, pdf...

<li><tt> img  &lt;image file&gt; &lt;scale&gt; &lt;dx&gt; &lt;dy&gt;</tt>
-- Рисование изображения. Применимо к шагам point, area (в этом случае
картинка рисуется в центре площади). Картинка задается так же, как и в
свойстве patt.

<li><tt> img_filter &lt;fltgt;</tt> -- Установить фильтр растровых
изображений. Применимо к шагам point, area, text, map, используется совместно
со свойствами img и patt. Возможные значение: fast, good, best, nearest,
bilinear
(см. <a href="https://www.cairographics.org/manual/cairo-cairo-pattern-t.html#cairo-filter-t">https://www.cairographics.org/manual/cairo-cairo-pattern-t.html#cairo-filter-t</a>)


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render08.png align=right>
# Example for `patt` and `img` features


# fill background with a pattern and then with
# semi-transparent white color:
map fill 0x80FFFFFF
+      patt vyr_o.png 0.3

# draw polygon with contour and pattern filling
area:1 stroke 0xFF008000 1
+      patt vyr_o.png 0.3

# draw point with image
point:1 img skala.png 0.5

# draw image in the center of polygon
area:1 img skala.png 0.3

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render09.png align=right>
# Example for `img_filter` feature

# fill background with a pattern with `nearest` (=`fast`) filter
map    patt vyr_o.png 0.3
+      img_filter nearest

# fill polygon with a pattern with default (=`good`) filter
area:1 stroke 0xFF008000 1
+      patt vyr_o.png 0.3


</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render10.png align=right>
# картинки, нарисованные в слишком мелком масштабе

map    patt vyr_o.png 0.08

# Заливка картинкой в мелком масштабе рисуется однордным
# усредненным цветом
area:1 stroke 0xFF008000 1
+      patt vyr_o.png 0.0001

# Картинка в мелком масштабе рисуется как отдельная точка с
# усредненным цветом
point:1 img skala.png 0.0001

</div><br>

<li><tt> smooth &lt;distance&gt; </tt> -- Использовать закругленные
линии с заданным размером закругления. Применимо к шагам line, area,
используется совместно со свойствами stroke, fill, patt.

<li><tt> dash &lt;len1&gt; ... </tt> -- Использовать штриховые линии.
Параметры задают длины штрихов и промежутков между ними, так как это
принято в библиотеке Cairo. (Если параметр один - длины штрихов и
промежутков равны, если параметров более одного - они задают чередование
длин штрихов и промежутков между ними). Применимо к шагам line, area, text
используется совместно со свойством stroke.

<li><tt> cap round|butt|square </tt> -- Описывает, как рисовать
окончание линии. Применимо к шагам line, area, text, используется
совместно со свойством stroke. По умолчанию - round.

<li><tt> join round|miter </tt> -- Описывает, как рисовать
стыки сегментов линий. Применимо к шагам line, area, text, используется
совместно со свойством stroke. По умолчанию - round.


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render02.png align=right>
# Example for `smooth` feature

map fill 0xFFFFFFFF

area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
+      smooth 20

line:1 stroke 0xFF0000FF 2
+      smooth 20

point:1 stroke 0xFFFF0000 8


</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render03.png align=right>
# Example for `dash` feature

map fill 0xFFFFFFFF

area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
+      smooth 20
+      dash 5

line:1 stroke 0xFF0000FF 5
+      smooth 20
+      dash 20

line:1 stroke 0xFFFF00FF 5
+      smooth 20
+      dash 4 12 4 20

point:1 stroke 0xFFFF0000 8

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render04.png align=right>
# Example for `cap` feature

map fill 0xFFFFFFFF

area:1 stroke 0xFF00FF00 3
+      fill 0xFFAAFFAA
+      dash 10
+      join round

line:1 stroke 0xFF0000FF 5
+      cap square
+      dash 20

line:1 stroke 0xFFFF00FF 5
+      cap butt
+      dash 4 12 4 20

point:1 stroke 0xFFFF0000 8


</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render05.png align=right>
# Example for `join` feature

map fill 0xFFFFFFFF

area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA

line:1 stroke 0xFF0000FF 10
+      join miter
+      cap butt

line:1 stroke 0xFFFF00FF 10
+      join round
+      cap butt

point:1 stroke 0xFFFF0000 8


</div><br>

<li><tt> operator &lt;op&gt; </tt> -- Установить оператор рисования.
Возможные значения: clear, source, over, in, out, atop, dest,
dest_over, dest_in, dest_out, dest_atop, xor, add, saturate
(см. <a href="https://www.cairographics.org/operators/">https://www.cairographics.org/operators/</a>). Значение по умолчанию -
over. Применимо к шагам point, line, area, text, map.


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render06.png align=right>
# Пример использования свойства `operator`.
# Иногда надо сделать "странную" последовательность рисовки объектов
# или их частей (А над Б, Б над В, В над А). Это можно сделать, использовав
# разные операторы рисования.
# В данном случае я хочу сделать двойную линию, причем середина должна быть
# "прозрачна" для некоторых ранее нарисованных объектов (площадной объект).
# Кроме того, контур текста тоже сделаю прозрачным для зеленой заливки.

# шаг1: рисую площадной объект
area:1 stroke 0xFF007F00 3
+      fill 0xFFAAFFAA

# шаг2: рисую линейный объект (толстая синяя линяя)
line:1 stroke 0xFF0000FF 8
+      cap butt

# шаг3: стираю сердцевину линейном объекте
line:1 stroke 0xFFFFFFFF 4
+      operator clear

# шаги4 и 4а: рисую площадной объект в вырезанной области.
# Тут есть дурацкая проблема: С оператором dest_over
# свойства stroke и fill, будучи использованы в одном
# шаге рисования выглядят как примененные в обратном порядке,
# и заливка закроет часть контура. Чтобы все было правильно,
# делаю два шага: сперва контур, потом заливку.
area:1 stroke 0xFF007F00 3
+      operator dest_over
area:1 fill 0xFFAAFFAA
+      operator dest_over

# шаг5: текст, вырезаем контур
text:1 font 15 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      stroke 0xFFFFFFFF 4
+      operator clear

# шаг6: зеленая заливка в вырезанной области
area:1 fill 0xFFAAFFAA
+      operator dest_over

# шаг7: рисую белую заливку там, где не было ничего нарисовано.
map fill 0xFFFFFFFF
+      operator dest_over

# шаг8: текст
text:1 font 15 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF


</div><br>

<li><tt> lines &lt;lines&gt; ... </tt> -- Вместо самого объекта рисовать
дополнительные линии, привязанные к каким-то местам объекта (см. свойство
draw_pos). Аргументы - одно- или многосегментные линии в виде
json-массивов: [[x1,y1],[x2,y2]]... Для рисования линий используются те
же свойства, что и для рисования самого объекта (stroke, fill, cap,
smooth и т.д.). Для линейных и площадных объектов координты ориентированы
по направлению объекта: x вдоль линии, y - перпендикулярно, вправо от нее.
Для точечных объектов x вправо, y - вниз.

<li><tt> circles &lt;circle&gt; ... </tt> -- Вместо самого объекта
рисовать дополнительные окружности, привязанные к каким-то местам объекта
(см. свойство draw_pos). Аргументы - параметры окружностей в виде
трехэлементных json-массивов: [x,y,r]. Для рисования окружностей
используются те же свойства, что и для рисования самого объекта (stroke,
fill, cap, smooth и т.д.). Координты ориентированы по направлению
объекта: x вдоль линии, y - перпендикулярно, вправо от нее.

<li><tt>draw_pos (point|begin|end|dist|edist) </tt> -- Место рисования
элементов lines и circles: point -- в каждом узле объекта (значение по
умолчанию и единственное возможное значение для точечных объектов);
begin/end -- в начальной/конечной точке; dist -- периодически вдоль
объекта, на заданном расттоянии друг от друга (см. свойство draw_dist);
edist -- периодически вдоль объекта, примерно на заданном расcтоянии друг
от друга, так, чтобы расположение объектов было симметрично относительно
концов линии.

<li><tt> draw_dist &lt;dist&gt; [&lt;dist0&gt;] </tt> -- Расстояния,
использующиеся в <tt>draw_pos dist/edist</tt>. dist -- расстояние между
соседними местами рисования; dist0 -- расстояние от первой точки до
первого места рисования (а для свойства draw_pos edist - и расстояние от
последнего места рисования до последней точки объекта).


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render11.png align=right>
# Рисование дополнительных элементов

map fill 0xFFFFFFFF

# рисуем площадной объект
area:1 stroke 0xFF008000 1
+      fill 0xFFAAFFAA

# отмечаем узлы точки площадного синими кружками с
# красной заливкой (круг с центром в точке и радиусом 3)
area:1 stroke 0xFF0000FF 1
+      fill   0xFFFF0000
+      circles [0,0,3]

# зеленые штрихи, направленные вперед и влево от направления линии
area:1 stroke 0xFF008000 1
+      lines [[0,0],[3,-3]]
+      draw_pos edist
+      draw_dist 10



# линейный объект: линия
line:1 stroke 0xFF0000FF 1

# линейный объект: синие стрелки по краям
line:1 stroke 0xFF0000FF 1
+      lines [[6,-4],[0,0],[6,4]]
+      draw_pos begin
line:1 stroke 0xFF0000FF 1
+      lines [[-6,-4],[0,0],[-6,4]]
+      draw_pos end

# поперечные линии примерно через 20 точек, расстояние от обоих краев 12 точек:
line:1 stroke 0xFF0000FF 1
+      lines [[0,-4],[0,4],[4,4]]
+      draw_pos edist
+      draw_dist 20 12

# поперечные красные линии строго через 20 точек, расстояние
# от левого края 12 точек, от правого - какое получится:
line:1 stroke 0xFFFF0000 1
+      lines [[0,-4],[0,4],[4,4]]
+      draw_pos dist
+      draw_dist 20 12



# точечный объект - черная точка в центре:
point:1 stroke 0xFF000000 2

# рисуем точечный объект в виде двух треугольников
#  (координата x - вправо, y - вниз)
point:1 stroke 0xFFFF0000 1
+       lines [[-3,1],[0,-4],[3,1],[-3,1]]\
              [[-6,2],[0,-8],[6,2],[-6,2]]\


</div><br>

<li><tt> move_to &lt;max_distance&gt; (area|line):&lt;tnum&gt;  </tt> --
Сдвинуть точечный объект к ближайшему линейному объекту или ближайшей границе
площадного объекта типа type, но не далее max_distance.
Применимо к шагам типа point.

<li><tt> rotate_to &lt;max_distance&gt; (area|line):&lt;tnum&gt; </tt> --
То же, что и move_to, но картинка объекта также поворачивается по направлению
линии.

<li><tt> rotate &lt;angle,deg&gt; </tt> --
Повернуть картинку объекта или текст на фиксированный угол (градусы, по часовой стрелке).
Добавляется к собственным поворотам объекта или повороту с помощью свойства rotate_to.
Свойство применимо к шагам point, line, area, text. См ниже раздел про повороты объектов.


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render12.png align=right>
# Сдвигание тоек к ближайшем линиям.
# Иногда хочется, чтобы при рисовании точки точно
# попадали на линии (перевалы на хребет, отметки уреза воды на
# реки и озера, ж/д станции на ж/д)

map fill 0xFFFFFFFF

# площадной объект
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA

# линейный объект
line:1 stroke 0xFF0000FF 1

# точка - исходное положение
point:1 stroke 0xFF000000 4
point:1 stroke 0xFF000000 1
+ lines [[0,0],[0,-10],[6,-8],[0,-6]]

# точка - сдвинута к границе ближайшего площадного объекта
# (но не дальше 30 точек)
point:1 stroke 0xFF0000FF 4
+ move_to 30 area:1
point:1 stroke 0xFF000000 1
+ lines [[0,0],[0,-10],[6,-8],[0,-6]]
+ move_to 30 area:1

# точка - сдвинута к ближайшей линии типа 1 или площадному
# объекту типа 1 (но не дальше 30 точек) и повернута
point:1 stroke 0xFFFF0000 4
+ rotate_to 30 line:1 area:1
point:1 stroke 0xFF000000 1
+ lines [[0,0],[0,-10],[6,-8],[0,-6]]
+ rotate_to 30 line:1 area:1


</div><br>

<li><tt> sel_range &lt;width&gt; &lt;color&gt; </tt> -- Нарисовать
предполагаемый диапазон объекта, по которому он выбирается из базы
данных. Для расчета диапазона используются остальные правила рисования
(например, stroke с ненулевой толщиной линии увеличивает диапазон на
толщину линии, картинка - на диагональный размер картинки и т.п.)
Для поиска текста используется параметр max_text_size (см.ниже).


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_examples/render13.png align=right>
# Показ границ объектов, по которым производится их выборка.

map fill 0xFFFFFFFF

# площадной объект
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
+      sel_range 0xFFFF0000 0.5

# линейный объект
line:1 stroke 0xFF0000FF 4
+      sel_range 0xFFFF00FF 0.5

# точка - исходное положение
point:1 stroke 0xFFFF0000 4
+       sel_range 0xFFFF00FF 0.5

# точка - сдвинута к ближайшей линии типа 1 или площадному
# объекту типа 1 (но не дальше 20 точек)
point:1 stroke 0xFFFF0000 4
+       move_to 20 line:1 area:1
+       sel_range 0xFFFF00FF 0.5

# По умолчанию ищется текст с размером до 1024x1024 точек.
# Это можно изменить командой max_text_size
max_text_size 10

text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      sel_range 0xFFFF00FF 0.5

</div><br>

<li><tt> name  &lt;name&gt; </tt> -- Объявить название шага (для показа в
интерфейсе). По умолчанию название составляется из типа объекта,
напрмер "line:0x25".

<li><tt> group &lt;name&gt; </tt> -- Название группы для данного шага.
Группа может включать несколько шагов.



</ul>

<p>В одном шаге рисования могут присутствовать несколько свойств. На
каждом шаге рисование происходит в следующем порядке:

<ul>

<li>Определяется диапазон, в котором надо искать объекты. На него влияют
свойства, которые приводят к сдвигу объектов или созданию картинки
конечного размера: stroke, img, patt, move_to, rotate_to.
Для текстовых объектов используется некий фиксированный размер
(по умолчанию 1024 точки -- TODO: сделать настраиваемым!)

<li>Если шаг имеет тип point, line, area, text, то выбираются соответствующие
объекты в нужном диапазоне.

<li>Если присутствует свойство sel_range, то рисуются прямоугольники
вокруг объектов.

<li>Настраивается оператор рисования (свойство operator), настраивается
шрифт (свойство font).

<li>Если присутствуют свойства stroke, fill, patt, то строится "путь"
рисования (path).

<li>Выполняется заливка картинкой (свойство patt).

<li>Выполняется заливка цветом (свойство fill).

<li>Выполняется рисование контура (свойство stroke). При этом
настраиваются параметры рисования, соответствующие свойствам dash, cap,
join.

<li>Выполняется рисование картинок (свойство img).

<li>Выполняется рисование текста (свойство write).
</ul>

<p>Если хочется использовать другой порядок (например, сперва контур,
потом заливку, потом паттерн) - придется сделать несколько последовательных
шагов рисования.

<p>Дополнительные команды, которые могут встречаться в конфигурационном файле:

<ul>

<li><tt> set_ref file &lt;filename&gt; </tt> -- установить "естественную"
привязку карты из файла (сейчас поддерживаются только файлы OziExplorer).


<li><tt> set_ref nom &lt;name&gt; &lt;dpi&gt;</tt> -- установить "естественную"
привязку карты по советскому номенклатурному листу.

<li><tt> max_text_size  &lt;number&gt;</tt> -- изменить максимальный размер текста
(в точках). Этот параметр используется при поиске текстовых объектов на карте.
Значение по умолчанию - 1024 точки.

<li><tt> define &lt;name&gt; &lt;definition&gt;</tt> -- переопределить
некое слово. В последующем файле все слова &lt;name&gt; будут заменены на
&lt;definition&gt;. Замена производится один раз, заменяются только целые
слова.

<li>

</ul>

<p>В первом случае привязка читается из файла (сейчас поддерживаются
только OziExplorer map-файлы), во втором задается в виде имени советского
номенклатурного листа (например, j42-010) и разрешения картинки (в точках
на дюйм, например 300). Использовуется "расширенный формат" номенклатурных
названий, допускающий одиночные листы (например r36-010) и "диапазоны" листов
(например j42-040.3x3 -- блок из девяти одиночных листов).

<p>При рисовании карты может использоваться любая привязка (например, во
вьюере можно менять масштаб карты). "Естественная" привязка выбирается по
умолчанию, кроме того, она задает характерные размеры объектов (толщины
линий, величину картинок и т.п.). Этого, впрочем, пока не сделано, сейчас
толщины линий и т.п. всегда фиксированы.




<h4>TODO - чего пока не хватает</h4>

<p>Рисование границы карты (контур, обрезка объектов, заливка). Возможно,
делать в шаге рисования типа map.

<p>Установка границы карты через конфигурационный файл (чтобы можно было
использовать разную границу для разных картинок). Возможно, использовать
границу из файла привязки.

<p>Правильные повороты и масштабирование объектов.

<p>Возможность отключать в интерфейсе свойства move_to, rotate_to, а,
может, и любые свойства.

<p>Перемасштабирование толщин линий и т.п. при рисовании.

<p>Более разверyтый интерфейс команды ms2mapdr render: параметры для
задания привязки и масштаба линий, исключения заданных групп шагов
рисования и т.п.

<p>Алиасы для цветов и типов объектов в конфигурационном файле.

<p>Включение других файлов при чтении конфигурационного файла.

<!--#################################################################-->
<hr><h3>Наклон объектов и подписей</h3>

<p>Объекты имеют параметр "наклон" (angle). Наклон применяется только к
тексту, растровым картинкам или картинкам, нарисованным с помощью свойств
lines и circles, но не к координатам объекта. Наклон может отсутствовать,
в этом случае картинка объекта ориентируется на верх карты. Если наклон
задан, то он отсчитывается от географического севера, по часовой
стрелке.

<p>Свойство рисования rotate_to ориентирует картинку объекта по указанной линии,
игнорируя его собственный наклон.

<p>Свойство рисования rotate добавляет к наклону (собственному или
возникшему из-за использования rotate_to) фиксированный угол (в градусах,
по часовой стрелке).


<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_ex_ang/render1.png align=right>
# Примеры объектов с наклонами. Из трех точечных и трех текстовых
# объектов левые не имеют собственного наклона, они ориентированы на верх
# карты; центральные имеют наклон 0, они ориентированы на север. правые
# имеют собственный наклон 20 градусов.

# площадной и линейный объекты
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
line:1 stroke 0xFF0000FF 1

# точка:1 -- картинка и точка поверх
point:1 img ohotn.png 0.4
point:1 stroke 0xFFFF0000 3

# шаг5: текст
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_ex_ang/render2.png align=right>
# Тут используется свойство rotate_to. Все точечные
# объекты ориентируются по линии.

# площадной и линейный объекты
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
line:1 stroke 0xFF0000FF 1

# точка:1 -- картинка
point:1 img ohotn.png 0.4
      + rotate_to 30 line:1
point:1 stroke 0xFFFF0000 3
      + rotate_to 30 line:1

# шаг5: текст
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_ex_ang/render3.png align=right>
# То же, но с картинками, нарисованными с помощью
# свойства lines вместо растровой картинки.

# площадной и линейный объекты
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
line:1 stroke 0xFF0000FF 1

# точка:1 -- картинка
# ось x направлена вправо, ось y - вниз
point:1 stroke 0xFF000000 2
+ lines [[0,0],[0,10],[6,8],[0,6]]
point:1 stroke 0xFFFF0000 3

# шаг5: текст
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_ex_ang/render4.png align=right>
# площадной и линейный объекты
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
line:1 stroke 0xFF0000FF 1

# точка:1 -- картинка
point:1 stroke 0xFF000000 2
+       lines [[0,0],[0,10],[6,8],[0,6]]
+       rotate_to 30 line:1
point:1 stroke 0xFFFF0000 3
+       rotate_to 30 line:1

# шаг5: текст
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4

</div><br>

<div style="border-style:solid; border-width:0.5;
            margin:3px; padding: 3px; color: black;
            font-family:monospace; white-space:pre">
<img src=render_ex_ang/render5.png align=right>
# Точки дополнительно повернуты на фиксированный
# угол 10 градусов

# площадной и линейный объекты
area:1 stroke 0xFF00FF00 1
+      fill 0xFFAAFFAA
line:1 stroke 0xFF0000FF 1

# точка:1 -- картинка
point:1 stroke 0xFF000000 2
+       lines [[0,0],[0,10],[6,8],[0,6]]
+       rotate 10
point:1 stroke 0xFFFF0000 3
+       rotate 10

# шаг5: текст
text:1 font 10 "DejaVu Sans:Bold:semicondensed:rgba=none"
+      write 0xFF0000FF
+      stroke 0xFFFFFFFF 4
+      rotate 10

</div><br>
</body>
</html>
